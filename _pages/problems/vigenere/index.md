---
layout: default
title: Набор проблем 2. Crypto. Vigenère (Виженèр).
---
# Vigenère (Виженèр)

## Коротко

Создайте программу, которая будет шифровать сообщения с помощью шифра Vigenère, как показано ниже.
```
$ ./vigenere ABC
plaintext:  HELLO
ciphertext: HFNLP
```
## Объяснение

Шифр Vigenère дополняет функционал [шифра Цезарь]({{ "/problems/caesar/" | relative_url }}), шифруя сообщения последовательностью ключей (или, скажем по-другому, ключевым словом). Другими словами, если `p` представляет из себя какой-то простой текст, а `k` является ключевым словом (т.е. словом, состоящим из алфавитных букв, где A представляет 0, B представляет 1, C представляет 2, …​ и Z представляет 25), то в простом тексте `c` каждой буквой будет *c<sub>i</sub>*. В зашифрованный текст `c` преобразуется следующим образом:

*c<sub>i</sub> = (p<sub>i</sub> + k<sub>j</sub>) mod 26*

Заметьте, что в этом шифре используется *k<sub>j</sub>* вместо обычной *k*. И если *k* будет короче *p*, тогда буквы в *k* нужно будет повторно использовать, пока не зашифруется весь *p*.

Другими словами, если Виженèр (был такой человек) хотел бы кому-нибудь по секрету сказать "HELLO", используя ключевое слово, например, "ABC" - он бы зашифровал букву "H" ключом "0" (т.е. буквой "A"), букву "E" ключом 1 (т.е. буквой "B"), первую "L" ключом "2" (т.е. буквой "C"), и в этот момент он бы израсходовал все буквы ключевого слова, поэтому ему пришлось бы повторно использовать ключевое слово (его часть), начав с самой первой буквы, чтобы зашифровать вторую "L" еще раз, воспользовавшись ключом "0" (т.е. буквой "A"). И наконец к последней букве "О" будет применена "1" (т.е. буква "B"). В итоге вместо HELLO Виженèр скажет HFNLP.

**Таблица 1. Шифрование слова HELLO ключевым словом ABC (ABCAB из-за **

**повторного использования) дает результат HFNLP.**

<table>
  <tr>
    <td>простой текст
</td>
    <td>H</td>
    <td>E</td>
    <td>L</td>
    <td>L</td>
    <td>O</td>
  </tr>
  <tr>
    <td>+ ключ
</td>
    <td>A</td>
    <td>B</td>
    <td>C</td>
    <td>A</td>
    <td>B</td>
  </tr>
  <tr>
    <td></td>
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>0</td>
    <td>1</td>
  </tr>
  <tr>
    <td>= шифрованный текст
</td>
    <td>H</td>
    <td>F</td>
    <td>N</td>
    <td>L</td>
    <td>P</td>
  </tr>
</table>


## Описание

Разработайте и реализуйте программу, которая будет шифровать сообщения используя шифр Виженèра.

Начните писать вашу программу в файле `vigenere.c`, который будет находиться в папке `vigenere`

Ваша программа должна принимать только один аргумент командной строки - ключевое слово *k*, состоящее только из алфавитных букв.

Если ваша программа будет запущена без каких-либо дополнительных аргументов командной строки, с количеством превышающим один аргумент или с одним аргументом, который содержит не алфавитный символ, то ваша программа должна будет вывести на экран ошибку (текст ошибки на ваше усмотрение) и при этом `main` должна сразу вернуть (или вывести на экран) значение `1` (обычно ею обозначают ошибку).

В противном случае ваша программа должна продолжать просить пользователя ввести простой текст *p* (выводя на экран `plaintext:`), который будет зашифрован с помощью ключа *k* шифром Виженèра и завершится, выдав число `0` - результат работы функции `main`. Зашифрованный текст отобразится после `ciphertext:` и окончится новой строкой (`\n`).

Символы в *k* должны представляться следующим образом: `A` и `a` как 0, `B` и `b` как 1, …​ и наконец `Z` и `z` как 25.

Ваша программа должна применять шифр Виженèра только к буквенным символам переменной *p*. Все другие символы (числа, знаки, пробелы, знаки препинания и т.п.) выводятся без изменений. Более того, если ваш код будет готов применить *j<sup>ый</sup>* символ переменной *k* на *i<sup>ый</sup>* символ переменной *p*, но символ окажется неалфавитным, вы должны будете применить этот *j<sup>ый</sup>* символ переменной *k* на следующий уже алфавитный символ переменной *p*. Т.е. вам нельзя продвигаться к следующему символу *k*, пока он не будет применен к алфавитному символу простого текста *p*.

Ваша программа должна сохранить регистр букв переменной *p*.

## Использование

Ваша программа должна проделывать тоже самое, что показано в примере ниже.
```
$ ./vigenere 13
Usage: ./vigenere k
```
```
$ ./vigenere
Usage: ./vigenere k
```
```
$ ./vigenere bacon and eggs
Usage: ./vigenere k
```
```
$ ./vigenere bacon
plaintext: Meet me at the park at eleven am
ciphertext: Negh zf av huf pcfx bt gzrwep oz
```
## Подсказка

Не знаете с чего начать? Эта программа очень схожа с [Цезарь]({{ "/problems/caesar/" | relative_url }})! Только на этот раз вам нужно определить, какой именно символ *k* вы будете использовать, находясь в процессе перебирания (итерации) символов *p*.

## Проверка
```
check50 cs50/2017/x/vigenere
```

Вас потребуют ввести логин (**GitHub username**) и пароль (**GitHub password**) от вашей учетной записи на Github'е, которую вы можете завести, пройдя по данной ссылке [https://github.com/join](https://github.com/join).

Зайдите на сайт [cs50.me](https://cs50.me/), используя всё ту же учетную запись GitHub'а и нажмите на зеленую кнопку **authorize submit50** (Это действие производится только один раз).